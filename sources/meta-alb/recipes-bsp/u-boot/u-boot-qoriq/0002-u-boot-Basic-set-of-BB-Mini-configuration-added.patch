From 7e33b80ea0e3276ea168173587322838ace3c8b3 Mon Sep 17 00:00:00 2001
From: Heinz Wrobel <Heinz.Wrobel@nxp.com>
Date: Thu, 25 Feb 2021 11:15:09 +0100
Subject: [PATCH 2/2] u-boot: Basic set of BB Mini configuration added

This adds a functional set of BB Mini configurations to support
NOR and SD boot without TFA. This is similar to prior usage in ALB,
but not identical.
The memory map has been adapted to mirror LSDK. Specifically the
environment in flash is in a different location.

Signed-off-by: Heinz Wrobel <Heinz.Wrobel@nxp.com>
---
 arch/arm/Kconfig                              |  20 +
 arch/arm/cpu/armv8/Kconfig                    |   1 +
 arch/arm/dts/Makefile                         |   1 +
 arch/arm/dts/fsl-ls2084a-bbmini.dts           |  75 ++++
 arch/arm/dts/fsl-ls2084a.dtsi                 | 203 ++++++++++
 board/freescale/ls2084abbmini/Kconfig         |  34 ++
 board/freescale/ls2084abbmini/MAINTAINERS     |   7 +
 board/freescale/ls2084abbmini/Makefile        |   8 +
 board/freescale/ls2084abbmini/README          | 162 ++++++++
 board/freescale/ls2084abbmini/ddr.c           | 186 +++++++++
 board/freescale/ls2084abbmini/ddr.h           |  57 +++
 .../ls2084abbmini/eth_ls2084abbmini.c         | 138 +++++++
 board/freescale/ls2084abbmini/ls2084abbmini.c | 375 ++++++++++++++++++
 .../ls2084abbmini/ls2084abbmini_qixis.h       |  19 +
 configs/ls2084abbmini_defconfig               |  82 ++++
 configs/ls2084abbmini_sdcard_defconfig        |  95 +++++
 include/configs/ls2084abbmini.h               | 278 +++++++++++++
 17 files changed, 1741 insertions(+)
 create mode 100644 arch/arm/dts/fsl-ls2084a-bbmini.dts
 create mode 100644 arch/arm/dts/fsl-ls2084a.dtsi
 create mode 100644 board/freescale/ls2084abbmini/Kconfig
 create mode 100644 board/freescale/ls2084abbmini/MAINTAINERS
 create mode 100644 board/freescale/ls2084abbmini/Makefile
 create mode 100644 board/freescale/ls2084abbmini/README
 create mode 100644 board/freescale/ls2084abbmini/ddr.c
 create mode 100644 board/freescale/ls2084abbmini/ddr.h
 create mode 100644 board/freescale/ls2084abbmini/eth_ls2084abbmini.c
 create mode 100644 board/freescale/ls2084abbmini/ls2084abbmini.c
 create mode 100644 board/freescale/ls2084abbmini/ls2084abbmini_qixis.h
 create mode 100644 configs/ls2084abbmini_defconfig
 create mode 100644 configs/ls2084abbmini_sdcard_defconfig
 create mode 100644 include/configs/ls2084abbmini.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index b21e1fdc00..594d0df61e 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1218,6 +1218,25 @@ config TARGET_LS2081ARDB
 	  development platform that supports the QorIQ LS2081A/LS2041A
 	  Layerscape Architecture processor.
 
+config TARGET_LS2084ABBMINI
+	bool "Support ls2084abbmini"
+	select ARCH_LS2080A
+	select ARM64
+	select ARMV8_MULTIENTRY
+	select ARCH_SUPPORT_TFABOOT
+	select BOARD_LATE_INIT
+	select SUPPORT_SPL
+	select FSL_DDR_BIST
+	select FSL_DDR_INTERACTIVE if !SPL
+	imply SCSI
+	imply SCSI_AHCI
+	help
+	  Support for NXP BlueBox Mini platform.
+	  The BlueBox Mini Reference design is a high-performance
+	  development platform that supports the QorIQ LS2084A
+	  Layerscape Architecture processor, teh S32V234 automotive
+	  processor, and the S32R27 ASIL-D capable MCU.
+
 config TARGET_LX2160ARDB
 	bool "Support lx2160ardb"
 	select ARCH_LX2160A
@@ -1852,6 +1871,7 @@ source "board/freescale/ls2080a/Kconfig"
 source "board/freescale/ls2080aqds/Kconfig"
 source "board/freescale/ls2080ardb/Kconfig"
 source "board/freescale/ls1088a/Kconfig"
+source "board/freescale/ls2084abbmini/Kconfig"
 source "board/freescale/ls1028a/Kconfig"
 source "board/freescale/ls1021aqds/Kconfig"
 source "board/freescale/ls1043aqds/Kconfig"
diff --git a/arch/arm/cpu/armv8/Kconfig b/arch/arm/cpu/armv8/Kconfig
index c90567dc23..06a1e4514c 100644
--- a/arch/arm/cpu/armv8/Kconfig
+++ b/arch/arm/cpu/armv8/Kconfig
@@ -100,6 +100,7 @@ config PSCI_RESET
 	depends on !ARCH_EXYNOS7 && !ARCH_BCM283X && \
 		   !TARGET_LS2080A_SIMU && !TARGET_LS2080AQDS && \
 		   !TARGET_LS2080ARDB && !TARGET_LS2080A_EMU && \
+		   !TARGET_LS2084ABBMINI && \
 		   !TARGET_LS1088ARDB && !TARGET_LS1088AQDS && \
 		   !TARGET_LS1012ARDB && !TARGET_LS1012AFRDM && \
 		   !TARGET_LS1012A2G5RDB && !TARGET_LS1012AQDS && \
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index b4944259ea..0e85f62fd7 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -368,6 +368,7 @@ dtb-$(CONFIG_ARCH_LS1021A) += ls1021a-qds-duart.dtb \
 dtb-$(CONFIG_FSL_LSCH3) += fsl-ls2080a-qds.dtb \
 	fsl-ls2080a-rdb.dtb \
 	fsl-ls2081a-rdb.dtb \
+	fsl-ls2084a-bbmini.dtb \
 	fsl-ls2088a-rdb-qspi.dtb \
 	fsl-ls1088a-rdb.dtb \
 	fsl-ls1088a-qds.dtb \
diff --git a/arch/arm/dts/fsl-ls2084a-bbmini.dts b/arch/arm/dts/fsl-ls2084a-bbmini.dts
new file mode 100644
index 0000000000..28d8affde2
--- /dev/null
+++ b/arch/arm/dts/fsl-ls2084a-bbmini.dts
@@ -0,0 +1,75 @@
+/*
+ * NXP ls2084a RDB board device tree source
+ *
+ * Copyright 2016 NXP Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+
+#include "fsl-ls2084a.dtsi"
+
+/ {
+	model = "NXP Layerscape 2084A BlueBox Mini";
+	compatible = "fsl,ls2080a-rdb", "fsl,ls2080a";
+};
+
+&i2c0 {
+	status = "okay";
+	u-boot,dm-pre-reloc;
+
+	pca9547@75 {
+		compatible = "nxp,pca9547";
+		reg = <0x75>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		i2c@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x00>;
+		};
+		i2c@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x01>;
+		};
+		i2c@2 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x02>;
+		};
+		i2c@3 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x03>;
+		};
+		i2c@4 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x04>;
+		};
+		i2c@5 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x05>;
+			rtc@68 {
+				compatible = "dallas,ds3232";
+				reg = <0x68>;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+};
+
+&i2c3 {
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
diff --git a/arch/arm/dts/fsl-ls2084a.dtsi b/arch/arm/dts/fsl-ls2084a.dtsi
new file mode 100644
index 0000000000..bf666b6048
--- /dev/null
+++ b/arch/arm/dts/fsl-ls2084a.dtsi
@@ -0,0 +1,203 @@
+// SPDX-License-Identifier: GPL-2.0+ OR X11
+/*
+ * NXP ls2084a SOC common device tree source
+ *
+ * Copyright 2016, 2020 NXP Semiconductor
+ */
+
+/ {
+	compatible = "fsl,ls2084a";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x00000000 0x80000000 0 0x80000000>;
+		      /* DRAM space - 1, size : 2 GB DRAM */
+	};
+
+	gic: interrupt-controller@6000000 {
+		compatible = "arm,gic-v3";
+		reg = <0x0 0x06000000 0 0x10000>, /* GIC Dist */
+		      <0x0 0x06100000 0 0x100000>; /* GICR (RD_base + SGI_base) */
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		interrupts = <1 9 0x4>;
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <1 13 0x8>, /* Physical Secure PPI, active-low */
+			     <1 14 0x8>, /* Physical Non-Secure PPI, active-low */
+			     <1 11 0x8>, /* Virtual PPI, active-low */
+			     <1 10 0x8>; /* Hypervisor PPI, active-low */
+	};
+
+	serial0: serial@21c0500 {
+		device_type = "serial";
+		compatible = "fsl,ns16550", "ns16550a";
+		reg = <0x0 0x21c0500 0x0 0x100>;
+		clock-frequency = <0>;	/* Updated by bootloader */
+		interrupts = <0 32 0x1>; /* edge triggered */
+	};
+
+	serial1: serial@21c0600 {
+		device_type = "serial";
+		compatible = "fsl,ns16550", "ns16550a";
+		reg = <0x0 0x21c0600 0x0 0x100>;
+		clock-frequency = <0>; 	/* Updated by bootloader */
+		interrupts = <0 32 0x1>; /* edge triggered */
+	};
+
+	fsl_mc: fsl-mc@80c000000 {
+		compatible = "fsl,qoriq-mc";
+		reg = <0x00000008 0x0c000000 0 0x40>,	 /* MC portal base */
+		      <0x00000000 0x08340000 0 0x40000>; /* MC control reg */
+	};
+
+	i2c0: i2c@2000000 {
+		status = "disabled";
+		compatible = "fsl,vf610-i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0 0x2000000 0x0 0x10000>;
+		interrupts = <0 34 0x4>; /* Level high type */
+	};
+
+	i2c1: i2c@2010000 {
+		status = "disabled";
+		compatible = "fsl,vf610-i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0 0x2010000 0x0 0x10000>;
+		interrupts = <0 34 0x4>; /* Level high type */
+	};
+
+	i2c2: i2c@2020000 {
+		status = "disabled";
+		compatible = "fsl,vf610-i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0 0x2020000 0x0 0x10000>;
+		interrupts = <0 35 0x4>; /* Level high type */
+	};
+
+	i2c3: i2c@2030000 {
+		status = "disabled";
+		compatible = "fsl,vf610-i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0 0x2030000 0x0 0x10000>;
+		interrupts = <0 35 0x4>; /* Level high type */
+	};
+
+	dspi: dspi@2100000 {
+		compatible = "fsl,vf610-dspi";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0 0x2100000 0x0 0x10000>;
+		interrupts = <0 26 0x4>; /* Level high type */
+		num-cs = <6>;
+	};
+
+	qspi: quadspi@1550000 {
+		compatible = "fsl,ls2080a-qspi";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0 0x20c0000 0x0 0x10000>,
+			<0x0 0x20000000 0x0 0x10000000>;
+		reg-names = "QuadSPI", "QuadSPI-memory";
+		status = "disabled";
+	};
+
+	esdhc: esdhc@0 {
+		compatible = "fsl,esdhc";
+		reg = <0x0 0x2140000 0x0 0x10000>;
+		interrupts = <0 28 0x4>; /* Level high type */
+		little-endian;
+		bus-width = <4>;
+	};
+
+	usb0: usb3@3100000 {
+		compatible = "fsl,layerscape-dwc3";
+		reg = <0x0 0x3100000 0x0 0x10000>;
+		interrupts = <0 80 0x4>; /* Level high type */
+		dr_mode = "host";
+	};
+
+	usb1: usb3@3110000 {
+		compatible = "fsl,layerscape-dwc3";
+		reg = <0x0 0x3110000 0x0 0x10000>;
+		interrupts = <0 81 0x4>; /* Level high type */
+		dr_mode = "host";
+	};
+
+	pcie1: pcie@3400000 {
+		compatible = "fsl,ls-pcie", "snps,dw-pcie";
+		reg = <0x00 0x03400000 0x0 0x80000   /* dbi registers */
+		       0x00 0x03480000 0x0 0x80000   /* lut registers */
+		       0x20 0x00000000 0x0 0x20000>; /* configuration space */
+		reg-names = "dbi", "lut", "config";
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+		num-lanes = <4>;
+		bus-range = <0x0 0xff>;
+		ranges = <0x81000000 0x0 0x00000000 0x20 0x00020000 0x0 0x00010000   /* downstream I/O */
+			  0x82000000 0x0 0x40000000 0x20 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
+	};
+
+	pcie2: pcie@3500000 {
+		compatible = "fsl,ls-pcie", "snps,dw-pcie";
+		reg = <0x00 0x03500000 0x0 0x80000   /* dbi registers */
+		       0x00 0x03580000 0x0 0x80000   /* lut registers */
+		       0x28 0x00000000 0x0 0x20000>; /* configuration space */
+		reg-names = "dbi", "lut", "config";
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+		num-lanes = <4>;
+		bus-range = <0x0 0xff>;
+		ranges = <0x81000000 0x0 0x00000000 0x28 0x00020000 0x0 0x00010000   /* downstream I/O */
+			  0x82000000 0x0 0x40000000 0x28 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
+	};
+
+	pcie3: pcie@3600000 {
+		compatible = "fsl,ls-pcie", "snps,dw-pcie";
+		reg = <0x00 0x03600000 0x0 0x80000   /* dbi registers */
+		       0x00 0x03680000 0x0 0x80000   /* lut registers */
+		       0x30 0x00000000 0x0 0x20000>; /* configuration space */
+		reg-names = "dbi", "lut", "config";
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+		num-lanes = <8>;
+		bus-range = <0x0 0xff>;
+		ranges = <0x81000000 0x0 0x00000000 0x30 0x00020000 0x0 0x00010000   /* downstream I/O */
+			  0x82000000 0x0 0x40000000 0x30 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
+	};
+
+	pcie4: pcie@3700000 {
+		compatible = "fsl,ls-pcie", "snps,dw-pcie";
+		reg = <0x00 0x03700000 0x0 0x80000   /* dbi registers */
+		       0x00 0x03780000 0x0 0x80000   /* lut registers */
+		       0x38 0x00000000 0x0 0x20000>; /* configuration space */
+		reg-names = "dbi", "lut", "config";
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+		num-lanes = <4>;
+		bus-range = <0x0 0xff>;
+		ranges = <0x81000000 0x0 0x00000000 0x38 0x00020000 0x0 0x00010000   /* downstream I/O */
+			  0x82000000 0x0 0x40000000 0x38 0x40000000 0x0 0x40000000>; /* non-prefetchable memory */
+	};
+
+	sata: sata@3200000 {
+			compatible = "fsl,ls2080a-ahci";
+			reg = <0x0 0x3200000 0x0 0x10000>;
+			interrupts = <0 133 0x4>; /* Level high type */
+			status = "disabled";
+	};
+
+};
diff --git a/board/freescale/ls2084abbmini/Kconfig b/board/freescale/ls2084abbmini/Kconfig
new file mode 100644
index 0000000000..f9ae4f1bfc
--- /dev/null
+++ b/board/freescale/ls2084abbmini/Kconfig
@@ -0,0 +1,34 @@
+
+if TARGET_LS2084ABBMINI
+
+config SYS_BOARD
+	default "ls2084abbmini"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "fsl-layerscape"
+
+config SYS_CONFIG_NAME
+	default "ls2084abbmini"
+
+source "board/freescale/common/Kconfig"
+
+if FSL_LS_PPA
+config SYS_LS_PPA_FW_ADDR
+	hex "PPA Firmware Addr"
+	default 0x20400000 if SYS_LS_PPA_FW_IN_XIP && QSPI_BOOT
+	default 0x580400000 if SYS_LS_PPA_FW_IN_XIP
+	default 0x400000 if SYS_LS_PPA_FW_IN_MMC
+
+if CHAIN_OF_TRUST
+config SYS_LS_PPA_ESBC_ADDR
+	hex "PPA Firmware HDR Addr"
+	default 0x20680000 if SYS_LS_PPA_FW_IN_XIP && QSPI_BOOT
+	default 0x580680000 if SYS_LS_PPA_FW_IN_XIP
+	default 0x680000 if SYS_LS_PPA_FW_IN_MMC
+endif
+endif
+
+endif
diff --git a/board/freescale/ls2084abbmini/MAINTAINERS b/board/freescale/ls2084abbmini/MAINTAINERS
new file mode 100644
index 0000000000..e0bf71739c
--- /dev/null
+++ b/board/freescale/ls2084abbmini/MAINTAINERS
@@ -0,0 +1,7 @@
+LS2084ABBMINI BOARD
+M:	Heinz Wrobel <Heinz.Wrobel@nnxp.com>
+S:	Maintained
+F:	board/freescale/ls2084abbmini/
+F:	board/freescale/ls2084a/ls2080abbmini.c
+F:	include/configs/ls2084abbmini.h
+F:	configs/ls2080abbmini_defconfig
diff --git a/board/freescale/ls2084abbmini/Makefile b/board/freescale/ls2084abbmini/Makefile
new file mode 100644
index 0000000000..b6c7afbb06
--- /dev/null
+++ b/board/freescale/ls2084abbmini/Makefile
@@ -0,0 +1,8 @@
+#
+# Copyright 2016 NXP
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+obj-y += ls2084abbmini.o eth_ls2084abbmini.o
+obj-y += ddr.o
diff --git a/board/freescale/ls2084abbmini/README b/board/freescale/ls2084abbmini/README
new file mode 100644
index 0000000000..b154c7ab0e
--- /dev/null
+++ b/board/freescale/ls2084abbmini/README
@@ -0,0 +1,162 @@
+Overview
+--------
+The LS2080A Reference Design (RDB) is a high-performance computing,
+evaluation, and development platform that supports the QorIQ LS2080A
+and LS2088A (and its personalitites) Layerscape Architecture processor.
+
+LS2080A SoC Overview
+------------------
+The LS2080A integrated multicore processor combines eight ARM Cortex-A57
+processor cores with high-performance data path acceleration logic and network
+and peripheral bus interfaces required for networking, telecom/datacom,
+wireless infrastructure, and mil/aerospace applications.
+
+The LS2080A SoC includes the following function and features:
+
+ - Eight 64-bit ARM Cortex-A57 CPUs
+ - 1 MB platform cache with ECC
+ - Two 64-bit DDR4 SDRAM memory controllers with ECC and interleaving support
+ - One secondary 32-bit DDR4 SDRAM memory controller, intended for use by
+  the AIOP
+ - Data path acceleration architecture (DPAA2) incorporating acceleration for
+ the following functions:
+   - Packet parsing, classification, and distribution (WRIOP)
+   - Queue and Hardware buffer management for scheduling, packet sequencing, and
+     congestion management, buffer allocation and de-allocation (QBMan)
+   - Cryptography acceleration (SEC) at up to 10 Gbps
+   - RegEx pattern matching acceleration (PME) at up to 10 Gbps
+   - Decompression/compression acceleration (DCE) at up to 20 Gbps
+   - Accelerated I/O processing (AIOP) at up to 20 Gbps
+   - QDMA engine
+ - 16 SerDes lanes at up to 10.3125 GHz
+ - Ethernet interfaces
+   - Up to eight 10 Gbps Ethernet MACs
+   - Up to eight 1 / 2.5 Gbps Ethernet MACs
+ - High-speed peripheral interfaces
+   - Four PCIe 3.0 controllers, one supporting SR-IOV
+ - Additional peripheral interfaces
+   - Two serial ATA (SATA 3.0) controllers
+   - Two high-speed USB 3.0 controllers with integrated PHY
+   - Enhanced secure digital host controller (eSDXC/eMMC)
+   - Serial peripheral interface (SPI) controller
+   - Quad Serial Peripheral Interface (QSPI) Controller
+   - Four I2C controllers
+   - Two DUARTs
+   - Integrated flash controller (IFC 2.0) supporting NAND and NOR flash
+ - Support for hardware virtualization and partitioning enforcement
+ - QorIQ platform's trust architecture 3.0
+ - Service processor (SP) provides pre-boot initialization and secure-boot
+  capabilities
+
+LS2088A SoC Overview
+------------------
+The QorIQ LS2088A processor is built on the Layerscape
+architecture combining eight ARM A72 processor cores
+with advanced, high-performance datapath acceleration
+and network, peripheral interfaces required for
+networking, telecom, wireless infrastructure, aerospace
+applications and general-purpose embedded applications.
+
+Features summary:
+ - Eight 64-bit ARM v8 Cortex-A72 CPUs
+ - Two 64-bit DDR4 SDRAM memory controller with ECC
+ - One 32-bit DDR3 SDRAM memory controller with ECC
+ - Data path acceleration architecture 2.0 (DPAA2)
+ - Ethernet interfaces
+ - IFC, 4 PCIe, 2 SATA, 2 USB, 1 SDXC, 2 DUARTs etc
+ - AIOP
+ - 8 * 1/10G + 8 *1G WRIOP
+ - L2 switch
+
+LS2088A is compliant to the Layerscape Chassis Generation 3.
+
+LS2088A SoC is similar to LS2085A Soc with some differences like
+1)Timer controller offset is different
+2)Errata A009635 and A008751 are fixed
+3)Maia core
+
+These differences can be detected via runtime during boot.
+So LS2085A, LS2088A will have common u-boot image
+
+LS2088A SoC has 3 more similar SoC personalities
+1)LS2048A, few difference w.r.t LS2088A:
+	a) Four 64-bit ARM v8 Cortex-A72 CPUs
+
+2)LS2084A, few difference w.r.t LS2088A:
+	a) No AIOP
+	b) No 32-bit DDR3 SDRAM memory
+	c) 5 * 1/10G + 5 *1G WRIOP
+	d) No L2 switch
+
+3)LS2044A, few difference w.r.t LS2084A:
+	a) Four 64-bit ARM v8 Cortex-A72 CPUs
+
+ LS2080ARDB board Overview
+ -----------------------
+ - SERDES Connections, 16 lanes supporting:
+      - PCI Express - 3.0
+      - SATA 3.0
+      - XFI
+ - DDR Controller
+     - Two ports of 72-bits (8-bits ECC) DDR4. Each port supports four
+       chip-selects and two DIMM connectors. Support is up to 2133MT/s.
+     - One port of 40-bits (8-bits ECC) DDR4 which supports four chip-selects
+       and two DIMM connectors. Support is up to 1600MT/s.
+ -IFC/Local Bus
+    - IFC rev. 2.0 implementation supporting Little Endian connection scheme.
+    - 128 MB NOR flash 16-bit data bus
+    - One 2 GB NAND flash with ECC support
+    - CPLD connection
+ - USB 3.0
+    - Two high speed USB 3.0 ports
+    - First USB 3.0 port configured as Host with Type-A connector
+    - Second USB 3.0 port configured as OTG with micro-AB connector
+ - SDHC adapter
+    - SD Card Rev 2.0 and Rev 3.0
+ - DSPI
+    - 128 MB high-speed flash Memory for boot code and storage (up to 108MHz)
+ - 4 I2C controllers
+ - Two SATA onboard connectors
+ - UART
+ - ARM JTAG support
+
+Memory map from core's view
+----------------------------
+0x00_0000_0000 .. 0x00_000F_FFFF	Boot Rom
+0x00_0100_0000 .. 0x00_0FFF_FFFF	CCSR
+0x00_1800_0000 .. 0x00_181F_FFFF	OCRAM
+0x00_3000_0000 .. 0x00_3FFF_FFFF	IFC region #1
+0x00_8000_0000 .. 0x00_FFFF_FFFF	DDR region #1
+0x05_1000_0000 .. 0x05_FFFF_FFFF	IFC region #2
+0x80_8000_0000 .. 0xFF_FFFF_FFFF	DDR region #2
+
+Other addresses are either reserved, or not used directly by u-boot.
+This list should be updated when more addresses are used.
+
+IFC region map from core's view
+-------------------------------
+During boot i.e. IFC Region #1:-
+  0x30000000 - 0x37ffffff : 128MB : NOR flash
+  0x3C000000 - 0x40000000 : 64MB  : CPLD
+
+After relocate to DDR i.e. IFC Region #2:-
+  0x5_1000_0000..0x5_1fff_ffff	Memory Hole
+  0x5_2000_0000..0x5_3fff_ffff	IFC CSx (CPLD, NAND and others 512MB)
+  0x5_4000_0000..0x5_7fff_ffff	ASIC or others 1GB
+  0x5_8000_0000..0x5_bfff_ffff	IFC CS0 1GB (NOR/Promjet)
+  0x5_C000_0000..0x5_ffff_ffff	IFC CS1 1GB (NOR/Promjet)
+
+Booting Options
+---------------
+a) NOR boot
+b) NAND boot
+
+Booting Linux flavors which do not support 48-bit VA (< Linux 3.18)
+-------------------------------------------------------------------
+One needs to use appropriate bootargs to boot Linux flavors which do
+not support 48-bit VA (for e.g. < Linux 3.18) by appending mem=2048M, as shown
+below:
+
+=> setenv bootargs 'console=ttyS1,115200 root=/dev/ram
+   earlycon=uart8250,mmio,0x21c0600,115200 default_hugepagesz=2m hugepagesz=2m
+   hugepages=16 mem=2048M'
diff --git a/board/freescale/ls2084abbmini/ddr.c b/board/freescale/ls2084abbmini/ddr.c
new file mode 100644
index 0000000000..72ce872c75
--- /dev/null
+++ b/board/freescale/ls2084abbmini/ddr.c
@@ -0,0 +1,186 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/clock.h>
+#include "ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+	u8 dq_mapping_0, dq_mapping_2, dq_mapping_3;
+#endif
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+	int slot;
+
+	if (ctrl_num > 2) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+
+	for (slot = 0; slot < CONFIG_DIMM_SLOTS_PER_CTLR; slot++) {
+		if (pdimm[slot].n_ranks)
+			break;
+	}
+
+	if (slot >= CONFIG_DIMM_SLOTS_PER_CTLR)
+		return;
+
+	/*
+	 * we use identical timing for all slots. If needed, change the code
+	 * to  pbsp = rdimms[ctrl_num] or pbsp = udimms[ctrl_num];
+	 */
+	if (popts->registered_dimm_en)
+		pbsp = rdimms[ctrl_num];
+	else
+		pbsp = udimms[ctrl_num];
+
+
+	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(ctrl_num) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm[slot].n_ranks &&
+		    (pdimm[slot].rank_density >> 30) >= pbsp->rank_gb) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found for data rate %lu MT/s\n"
+			"Trying to use the highest speed (%u) parameters\n",
+			ddr_freq, pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n"
+		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, wrlvl_ctrl_3 0x%x\n",
+		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb,
+		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
+		pbsp->wrlvl_ctl_3);
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+	if (ctrl_num == CONFIG_DP_DDR_CTRL) {
+		if (popts->registered_dimm_en)
+			printf("WARN: RDIMM not supported.\n");
+		/* force DDR bus width to 32 bits */
+		popts->data_bus_width = 1;
+		popts->otf_burst_chop_en = 0;
+		popts->burst_length = DDR_BL8;
+		popts->bstopre = 0;	/* enable auto precharge */
+		/*
+		 * Layout optimization results byte mapping
+		 * Byte 0 -> Byte ECC
+		 * Byte 1 -> Byte 3
+		 * Byte 2 -> Byte 2
+		 * Byte 3 -> Byte 1
+		 * Byte ECC -> Byte 0
+		 */
+		dq_mapping_0 = pdimm[slot].dq_mapping[0];
+		dq_mapping_2 = pdimm[slot].dq_mapping[2];
+		dq_mapping_3 = pdimm[slot].dq_mapping[3];
+		pdimm[slot].dq_mapping[0] = pdimm[slot].dq_mapping[8];
+		pdimm[slot].dq_mapping[1] = pdimm[slot].dq_mapping[9];
+		pdimm[slot].dq_mapping[2] = pdimm[slot].dq_mapping[6];
+		pdimm[slot].dq_mapping[3] = pdimm[slot].dq_mapping[7];
+		pdimm[slot].dq_mapping[6] = dq_mapping_2;
+		pdimm[slot].dq_mapping[7] = dq_mapping_3;
+		pdimm[slot].dq_mapping[8] = dq_mapping_0;
+		pdimm[slot].dq_mapping[9] = 0;
+		pdimm[slot].dq_mapping[10] = 0;
+		pdimm[slot].dq_mapping[11] = 0;
+		pdimm[slot].dq_mapping[12] = 0;
+		pdimm[slot].dq_mapping[13] = 0;
+		pdimm[slot].dq_mapping[14] = 0;
+		pdimm[slot].dq_mapping[15] = 0;
+		pdimm[slot].dq_mapping[16] = 0;
+		pdimm[slot].dq_mapping[17] = 0;
+	}
+#endif
+	/* To work at higher than 1333MT/s */
+	popts->half_strength_driver_enable = 0;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0x0;	/* 32 clocks */
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	/* optimize cpo for erratum A-009942 */
+	popts->cpo_sample = 0x6e;
+
+	if (ddr_freq < 2350) {
+		if (pdimm[0].n_ranks == 2 && pdimm[1].n_ranks == 2) {
+			/* four chip-selects */
+			popts->ddr_cdr1 = DDR_CDR1_DHC_EN |
+					  DDR_CDR1_ODT(DDR_CDR_ODT_80ohm);
+			popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_80ohm);
+			popts->twot_en = 1;	/* enable 2T timing */
+		} else {
+			popts->ddr_cdr1 = DDR_CDR1_DHC_EN |
+					  DDR_CDR1_ODT(DDR_CDR_ODT_60ohm);
+			popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_60ohm) |
+					  DDR_CDR2_VREF_RANGE_2;
+		}
+	} else {
+		popts->ddr_cdr1 = DDR_CDR1_DHC_EN |
+				  DDR_CDR1_ODT(DDR_CDR_ODT_100ohm);
+		popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_100ohm) |
+				  DDR_CDR2_VREF_RANGE_2;
+	}
+}
+
+#ifdef CONFIG_TFABOOT
+int fsl_initdram(void)
+{
+	gd->ram_size = tfa_get_dram_size();
+
+	if (!gd->ram_size)
+		gd->ram_size = fsl_ddr_sdram_size();
+
+	return 0;
+}
+#else
+int fsl_initdram(void)
+{
+#if defined(CONFIG_SPL) && !defined(CONFIG_SPL_BUILD)
+	gd->ram_size = fsl_ddr_sdram_size();
+#else
+	puts("Initializing DDR....using SPD\n");
+
+	gd->ram_size = fsl_ddr_sdram();
+#endif
+
+	return 0;
+}
+#endif /* CONFIG_TFABOOT */
diff --git a/board/freescale/ls2084abbmini/ddr.h b/board/freescale/ls2084abbmini/ddr.h
new file mode 100644
index 0000000000..c1be76ba69
--- /dev/null
+++ b/board/freescale/ls2084abbmini/ddr.h
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  1350, 0, 8,     6, 0x0708090B, 0x0C0D0E09,},
+	{2,  1666, 0, 10,    9, 0x090A0B0E, 0x0F11110C,},
+	{2,  1900, 0, 12,  0xA, 0x0B0C0E11, 0x1214140F,},
+	{2,  2300, 0, 12,  0xB, 0x0C0D0F12, 0x14161610,},
+	{}
+};
+
+static const struct board_specific_parameters rdimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+	udimm0,
+};
+
+static const struct board_specific_parameters *rdimms[] = {
+	rdimm0,
+	rdimm0,
+};
+
+
+#endif
diff --git a/board/freescale/ls2084abbmini/eth_ls2084abbmini.c b/board/freescale/ls2084abbmini/eth_ls2084abbmini.c
new file mode 100644
index 0000000000..2451be6550
--- /dev/null
+++ b/board/freescale/ls2084abbmini/eth_ls2084abbmini.c
@@ -0,0 +1,138 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2016, 2020 NXP
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <fsl_mdio.h>
+#include <miiphy.h>
+#include <phy.h>
+#include <fm_eth.h>
+#include <asm/io.h>
+#include <exports.h>
+#include <asm/arch/fsl_serdes.h>
+#include <fsl-mc/fsl_mc.h>
+#include <fsl-mc/ldpaa_wriop.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int board_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_FSL_MC_ENET)
+	int i;
+	struct memac_mdio_info mdio_info;
+	struct mii_dev *dev;
+	struct ccsr_gur *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	u32 srds_s1;
+	struct memac_mdio_controller *reg;
+
+	srds_s1 = in_le32(&gur->rcwsr[28]) &
+				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK;
+	srds_s1 >>= FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
+
+	reg = (struct memac_mdio_controller *)CONFIG_SYS_FSL_WRIOP1_MDIO2;
+	mdio_info.regs = reg;
+	mdio_info.name = DEFAULT_WRIOP_MDIO2_NAME;
+
+	/* Register the EMI 2 */
+	fm_memac_mdio_init(bis, &mdio_info);
+
+	switch (srds_s1) {
+	case 0x2A:
+		/* XFI retimer is on WRIOP1_DPMAC1, but without EMI1 hookup */
+		/* The problem is that we appear to need a phy address
+		 * for U-Boot to instantiate the port correctly. So
+		 * we use an invalid address to make it happen.
+		 */
+		wriop_set_phy_address(WRIOP1_DPMAC1, 0, 31);
+		wriop_disable_dpmac(WRIOP1_DPMAC2);
+		wriop_disable_dpmac(WRIOP1_DPMAC3);
+		wriop_disable_dpmac(WRIOP1_DPMAC4);
+		wriop_set_phy_address(WRIOP1_DPMAC5, 0, AQ_PHY_ADDR1);
+		wriop_set_phy_address(WRIOP1_DPMAC6, 0, AQ_PHY_ADDR2);
+		wriop_set_phy_address(WRIOP1_DPMAC7, 0, AQ_PHY_ADDR3);
+		wriop_disable_dpmac(WRIOP1_DPMAC8);
+		break;
+	default:
+		for (i = WRIOP1_DPMAC1; i < NUM_WRIOP_PORTS; i++) {
+			wriop_disable_dpmac(i);
+		}
+		printf("SerDes1 protocol 0x%x is not supported on NXP BlueBox Mini\n",
+		       srds_s1);
+		break;
+	}
+
+	for (i = WRIOP1_DPMAC5; i <= WRIOP1_DPMAC7; i++) {
+		switch (wriop_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_XGMII:
+			dev = miiphy_get_dev_by_name(DEFAULT_WRIOP_MDIO2_NAME);
+			wriop_set_mdio(i, dev);
+			break;
+		default:
+			break;
+		}
+	}
+
+	cpu_eth_init(bis);
+#endif /* CONFIG_FSL_MC_ENET */
+
+#ifdef CONFIG_PHY_AQUANTIA
+	/*
+	 * Export functions to be used by AQ firmware
+	 * upload application
+	 */
+	gd->jt->strcpy = strcpy;
+	gd->jt->mdelay = mdelay;
+	gd->jt->mdio_get_current_dev = mdio_get_current_dev;
+	gd->jt->phy_find_by_mask = phy_find_by_mask;
+	gd->jt->mdio_phydev_for_ethname = mdio_phydev_for_ethname;
+	gd->jt->miiphy_set_current_dev = miiphy_set_current_dev;
+#endif
+
+#ifdef CONFIG_PHY_AQUANTIA
+	/*
+	 * This patch is a bit awkward, but I do not know of a better
+	 * way. PHY LED configuration settings are board specific, so
+	 * they should not really be in the driver. However, we are
+	 * also second guessing the driver if we do it here.
+	 * Well, this should solve the issue, but it should likely
+	 * be redone in a more appropriate way.
+	 */
+	{
+		struct phy_device *phydev;
+		int i;
+
+		for (i = 0; i < 3; i++) {
+			char buf[16];
+
+			sprintf(buf, "DPMAC%d@xgmii", 5 + i);
+			phydev = mdio_phydev_for_ethname(buf);
+			if (phydev) {
+				/* Enable LEDs */
+				phy_write(phydev, MDIO_MMD_VEND1, 0xc43b, phy_read(phydev, MDIO_MMD_VEND1, 0xc43b) | 0x02);
+				phy_write(phydev, MDIO_MMD_VEND1, 0xc43c, phy_read(phydev, MDIO_MMD_VEND1, 0xc43c) | 0x02);
+
+				/* Set LED function */
+				phy_write(phydev, MDIO_MMD_VEND1, 0xc430, 0xc0e3); /* link */
+				phy_write(phydev, MDIO_MMD_VEND1, 0xc431, 0x000f); /* rx/tx activity */
+			}
+		}
+	}
+#endif
+
+	return pci_eth_init(bis);
+}
+
+#if defined(CONFIG_RESET_PHY_R)
+void reset_phy(void)
+{
+#if defined(CONFIG_FSL_MC_ENET)
+	mc_env_boot();
+#endif
+}
+#endif /* CONFIG_RESET_PHY_R */
diff --git a/board/freescale/ls2084abbmini/ls2084abbmini.c b/board/freescale/ls2084abbmini/ls2084abbmini.c
new file mode 100644
index 0000000000..3b80455108
--- /dev/null
+++ b/board/freescale/ls2084abbmini/ls2084abbmini.c
@@ -0,0 +1,375 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2016-2018, 2020 NXP
+ */
+#include <common.h>
+#include <env.h>
+#include <malloc.h>
+#include <errno.h>
+#include <netdev.h>
+#include <fsl_ifc.h>
+#include <fsl_ddr.h>
+#include <asm/io.h>
+#include <hwconfig.h>
+#include <fdt_support.h>
+#include <linux/libfdt.h>
+#include <fsl-mc/fsl_mc.h>
+#include <env_internal.h>
+#include <efi_loader.h>
+#include <i2c.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/ppa.h>
+#include <fsl_sec.h>
+#include <asm/arch-fsl-layerscape/fsl_icid.h>
+
+#ifdef CONFIG_FSL_QIXIS
+#include "../common/qixis.h"
+#include "ls2084abbmini_qixis.h"
+#endif
+#include "../common/vid.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+unsigned long long get_qixis_addr(void)
+{
+	unsigned long long addr;
+
+	if (gd->flags & GD_FLG_RELOC)
+		addr = QIXIS_BASE_PHYS;
+	else
+		addr = QIXIS_BASE_PHYS_EARLY;
+
+	/*
+	 * IFC address under 256MB is mapped to 0x30000000, any address above
+	 * is mapped to 0x5_10000000 up to 4GB.
+	 */
+	addr = addr  > 0x10000000 ? addr + 0x500000000ULL : addr + 0x30000000;
+
+	return addr;
+}
+
+int checkboard(void)
+{
+#ifdef CONFIG_FSL_QIXIS
+	u8 sw;
+#endif
+
+	printf("Board: NXP BlueBox Mini, ");
+
+#ifdef CONFIG_FSL_QIXIS
+	sw = QIXIS_READ(arch);
+	printf("Board Arch: V%d, ", sw >> 4);
+	printf("Board version: %c, boot from ", (sw & 0xf) + 'A' - 1);
+
+#ifdef CONFIG_SD_BOOT
+	printf("SD card\n");
+#else
+	sw = QIXIS_READ(brdcfg[0]);
+	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+	if (sw < 0x8)
+		printf("vBank: %d\n", sw);
+	else
+		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+
+	printf("FPGA: v%d.%d\n", QIXIS_READ(scver), QIXIS_READ(tagdata));
+#endif
+#endif
+
+	puts("SERDES1 Reference : ");
+	printf("Clock1 = 156.25MHz ");
+	printf("Clock2 = 156.25MHz");
+
+	puts("\nSERDES2 Reference : ");
+	printf("Clock1 = 100MHz ");
+	printf("Clock2 = 100MHz\n");
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	/* Board clock is not Qixis configurable on BlueBox Mini */
+	return 100000000;
+}
+
+static int select_i2c_ch_pca9547(u8 ch)
+{
+	int ret;
+
+#ifndef CONFIG_DM_I2C
+	ret = i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &ch, 1);
+#else
+	struct udevice *dev;
+
+	ret = i2c_get_chip_for_busnum(0, I2C_MUX_PCA_ADDR_PRI, 1, &dev);
+	if (!ret)
+		ret = dm_i2c_write(dev, 0, &ch, 1);
+#endif
+
+	if (ret) {
+		puts("PCA: failed to select proper channel\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int i2c_multiplexer_select_vid_channel(u8 channel)
+{
+	return select_i2c_ch_pca9547(channel);
+}
+
+int board_init(void)
+{
+#ifdef CONFIG_FSL_MC_ENET
+	u32 __iomem *irq_ccsr = (u32 __iomem *)ISC_BASE;
+#endif
+
+	init_final_memctl_regs();
+
+#ifdef CONFIG_ENV_IS_NOWHERE
+	gd->env_addr = (ulong)&default_environment[0];
+#endif
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+
+#ifdef CONFIG_FSL_QIXIS
+	QIXIS_WRITE(rst_ctl, QIXIS_RST_CTL_RESET_EN);
+#endif
+
+#ifdef CONFIG_FSL_CAAM
+	sec_init();
+#endif
+#ifdef CONFIG_FSL_LS_PPA
+	ppa_init();
+#endif
+
+#ifdef CONFIG_FSL_MC_ENET
+	/* invert AQR107 IRQ pins polarity */
+	out_le32(irq_ccsr + IRQCR_OFFSET / 4,
+	         (AQR107_IRQ_MASK1|AQR107_IRQ_MASK2|AQR107_IRQ_MASK3));
+#endif
+#ifdef CONFIG_FSL_CAAM
+	sec_init();
+#endif
+
+	return 0;
+}
+
+static int set_thermal_thresholds(void)
+{
+	int ret;
+	u8 byte;
+#ifdef CONFIG_DM_I2C
+	struct udevice *dev;
+#endif
+
+
+	/* Set the ADR7481 limits to 105C and hysteresis to 5C.
+	 * as early as posible. Today, the CPLD acts on things right
+	 * away, so this won't help if the box is too hot (or too cold!).
+	 * A future CPLD may mask things for a while after power up to
+	 * permit U-Boot to update the thermal limits before panic
+	 * kicks in.*/
+	select_i2c_ch_pca9547(I2C_MUX_CH_ADT7481);
+
+	/* We mask /ALERT so that we only check for overtemp */
+#ifndef CONFIG_DM_I2C
+	byte = 0x80;
+	ret = i2c_write(I2C_ADT7481_ADDR, 0x9, 1, &byte, 1);
+	byte = 0x05;
+	if (!ret)
+		ret = i2c_write(I2C_ADT7481_ADDR, 0x21, 1, &byte, 1);
+	byte = 105;
+	if (!ret)
+		ret = i2c_write(I2C_ADT7481_ADDR, 0x0b, 1, &byte, 1);
+	if (!ret)
+		ret = i2c_write(I2C_ADT7481_ADDR, 0x0d, 1, &byte, 1);
+	if (!ret)
+		ret = i2c_write(I2C_ADT7481_ADDR, 0x31, 1, &byte, 1);
+	if (!ret)
+		ret = i2c_write(I2C_ADT7481_ADDR, 0x19, 1, &byte, 1);
+	if (!ret)
+		ret = i2c_write(I2C_ADT7481_ADDR, 0x20, 1, &byte, 1);
+	if (!ret)
+		ret = i2c_write(I2C_ADT7481_ADDR, 0x39, 1, &byte, 1);
+#else
+	ret = i2c_get_chip_for_busnum(0, I2C_ADT7481_ADDR, 1, &dev);
+
+	byte = 0x80;
+	if (!ret)
+		ret = dm_i2c_write(dev, 0x9, &byte, 1);
+	byte = 0x05;
+		ret = dm_i2c_write(dev, 0x21, &byte, 1);
+	byte = 105;
+	if (!ret)
+		ret = dm_i2c_write(dev, 0x0b, &byte, 1);
+	if (!ret)
+		ret = dm_i2c_write(dev, 0x0d, &byte, 1);
+	if (!ret)
+		ret = dm_i2c_write(dev, 0x31, &byte, 1);
+	if (!ret)
+		ret = dm_i2c_write(dev, 0x19, &byte, 1);
+	if (!ret)
+		ret = dm_i2c_write(dev, 0x20, &byte, 1);
+	if (!ret)
+		ret = dm_i2c_write(dev, 0x39, &byte, 1);
+#endif
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+
+	return ret;
+}
+
+int board_early_init_f(void)
+{
+#ifdef CONFIG_SYS_I2C_EARLY_INIT
+	i2c_early_init_f();
+#endif
+	fsl_lsch3_early_init_f();
+	return 0;
+}
+
+int misc_init_r(void)
+{
+	set_thermal_thresholds();
+#ifdef CONFIG_VID
+	/* Preconfiguration of VID limits per LS2084A specification */
+	vid_set_mv_limits(1100, 1050, 950, 1100, 1075, 925, 900);
+
+	if (adjust_vdd(0))
+		printf("Warning: Adjusting core voltage failed.\n");
+#endif
+
+	/*
+	 * Default value of board env is based on filename which is
+	 * ls2084abbmini. Modify board env for other supported SoCs
+	 */
+	env_set("board", "ls2084abbmini");
+
+	return 0;
+}
+
+void detail_board_ddr_info(void)
+{
+	puts("\nDDR    ");
+	print_size(gd->bd->bi_dram[0].size + gd->bd->bi_dram[1].size, "");
+	print_ddr_info(0);
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+	if (soc_has_dp_ddr() && gd->bd->bi_dram[2].size) {
+		puts("\nDP-DDR ");
+		print_size(gd->bd->bi_dram[2].size, "");
+		print_ddr_info(CONFIG_DP_DDR_CTRL);
+	}
+#endif
+}
+
+#ifdef CONFIG_FSL_MC_ENET
+void fdt_fixup_board_enet(void *fdt)
+{
+	int offset;
+
+	offset = fdt_path_offset(fdt, "/soc/fsl-mc");
+
+	if (offset < 0)
+		offset = fdt_path_offset(fdt, "/fsl-mc");
+
+	if (offset < 0) {
+		printf("%s: ERROR: fsl-mc node not found in device tree (error %d)\n",
+		       __func__, offset);
+		return;
+	}
+
+	if (get_mc_boot_status() == 0 &&
+	    (is_lazy_dpl_addr_valid() || get_dpl_apply_status() == 0))
+		fdt_status_okay(fdt, offset);
+	else
+		fdt_status_fail(fdt, offset);
+}
+
+void board_quiesce_devices(void)
+{
+	fsl_mc_ldpaa_exit(gd->bd);
+}
+#endif
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	int i;
+	u16 mc_memory_bank = 0;
+
+	u64 *base;
+	u64 *size;
+	u64 mc_memory_base = 0;
+	u64 mc_memory_size = 0;
+	u16 total_memory_banks;
+
+	ft_cpu_setup(blob, bd);
+
+	fdt_fixup_mc_ddr(&mc_memory_base, &mc_memory_size);
+
+	if (mc_memory_base != 0)
+		mc_memory_bank++;
+
+	total_memory_banks = CONFIG_NR_DRAM_BANKS + mc_memory_bank;
+
+	base = calloc(total_memory_banks, sizeof(u64));
+	size = calloc(total_memory_banks, sizeof(u64));
+
+	/* fixup DT for the two GPP DDR banks */
+	base[0] = gd->bd->bi_dram[0].start;
+	size[0] = gd->bd->bi_dram[0].size;
+	base[1] = gd->bd->bi_dram[1].start;
+	size[1] = gd->bd->bi_dram[1].size;
+
+#ifdef CONFIG_RESV_RAM
+	/* reduce size if reserved memory is within this bank */
+	if (gd->arch.resv_ram >= base[0] &&
+	    gd->arch.resv_ram < base[0] + size[0])
+		size[0] = gd->arch.resv_ram - base[0];
+	else if (gd->arch.resv_ram >= base[1] &&
+		 gd->arch.resv_ram < base[1] + size[1])
+		size[1] = gd->arch.resv_ram - base[1];
+#endif
+
+	if (mc_memory_base != 0) {
+		for (i = 0; i <= total_memory_banks; i++) {
+			if (base[i] == 0 && size[i] == 0) {
+				base[i] = mc_memory_base;
+				size[i] = mc_memory_size;
+				break;
+			}
+		}
+	}
+
+	fdt_fixup_memory_banks(blob, base, size, total_memory_banks);
+
+	fdt_fsl_mc_fixup_iommu_map_entry(blob);
+
+	fsl_fdt_fixup_dr_usb(blob, bd);
+
+#ifdef CONFIG_FSL_MC_ENET
+	fdt_fixup_board_enet(blob);
+#endif
+
+	fdt_fixup_icid(blob);
+
+	return 0;
+}
+#endif
+
+void qixis_dump_switch(void)
+{
+#ifdef CONFIG_FSL_QIXIS
+	int i, nr_of_cfgsw;
+
+	QIXIS_WRITE(cms[0], 0x00);
+	nr_of_cfgsw = QIXIS_READ(cms[1]);
+
+	puts("DIP switch settings dump:\n");
+	for (i = 1; i <= nr_of_cfgsw; i++) {
+		QIXIS_WRITE(cms[0], i);
+		printf("SW%d = (0x%02x)\n", i, QIXIS_READ(cms[1]));
+	}
+#endif
+}
diff --git a/board/freescale/ls2084abbmini/ls2084abbmini_qixis.h b/board/freescale/ls2084abbmini/ls2084abbmini_qixis.h
new file mode 100644
index 0000000000..db3c6dc2a2
--- /dev/null
+++ b/board/freescale/ls2084abbmini/ls2084abbmini_qixis.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __LS2_RDB_QIXIS_H__
+#define __LS2_RDB_QIXIS_H__
+
+/* SYSCLK */
+#define QIXIS_SYSCLK_66			0x0
+#define QIXIS_SYSCLK_83			0x1
+#define QIXIS_SYSCLK_100		0x2
+#define QIXIS_SYSCLK_125		0x3
+#define QIXIS_SYSCLK_133		0x4
+#define QIXIS_SYSCLK_150		0x5
+#define QIXIS_SYSCLK_160		0x6
+#define QIXIS_SYSCLK_166		0x7
+
+#endif /*__LS2_RDB_QIXIS_H__*/
diff --git a/configs/ls2084abbmini_defconfig b/configs/ls2084abbmini_defconfig
new file mode 100644
index 0000000000..afe92440fd
--- /dev/null
+++ b/configs/ls2084abbmini_defconfig
@@ -0,0 +1,82 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS2084ABBMINI=y
+CONFIG_SYS_TEXT_BASE=0x30100000
+CONFIG_ENV_SIZE=0x2000
+CONFIG_ENV_SECT_SIZE=0x40000
+CONFIG_ENV_OFFSET=0x500000
+CONFIG_FSL_LS_PPA=y
+CONFIG_DM_GPIO=y
+CONFIG_NR_DRAM_BANKS=2
+CONFIG_AHCI=y
+CONFIG_SYS_MALLOC_F_LEN=0x6000
+CONFIG_FIT=y
+CONFIG_FIT_VERBOSE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_OF_STDOUT_VIA_ALIAS=y
+CONFIG_BOOTDELAY=10
+CONFIG_HUSH_PARSER=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyS1,115200 root=/dev/ram0 earlycon=uart8250,mmio,0x21c0600 ramdisk_size=0x2000000 default_hugepagesz=2m hugepagesz=2m hugepages=256"
+# CONFIG_USE_BOOTCOMMAND is not set
+CONFIG_MISC_INIT_R=y
+CONFIG_CMD_IMLS=y
+CONFIG_CMD_BOOTI=y
+CONFIG_CMD_GREPENV=y
+CONFIG_CMD_EEPROM=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_SETEXPR=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_DATE=y
+CONFIG_MP=y
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-ls2084a-bbmini"
+CONFIG_ENV_IS_IN_FLASH=y
+CONFIG_ENV_ADDR=0x580500000
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM=y
+CONFIG_SATA_CEVA=y
+CONFIG_FSL_CAAM=y
+CONFIG_DM_I2C=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_DM_MMC=y
+CONFIG_FSL_ESDHC=y
+CONFIG_MTD=y
+CONFIG_MTD_NOR_FLASH=y
+CONFIG_FLASH_CFI_DRIVER=y
+CONFIG_SYS_FLASH_USE_BUFFER_WRITE=y
+CONFIG_SYS_FLASH_CFI=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_AQUANTIA=y
+CONFIG_E1000=y
+CONFIG_MII=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCIE_LAYERSCAPE=y
+CONFIG_DM_RTC=y
+CONFIG_DM_SCSI=y
+CONFIG_CONS_INDEX=2
+CONFIG_SYS_NS16550=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_FSL_DSPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_STORAGE=y
+CONFIG_EFI_LOADER_BOUNCE_BUFFER=y
+CONFIG_DISTRO_DEFAULTS=y
diff --git a/configs/ls2084abbmini_sdcard_defconfig b/configs/ls2084abbmini_sdcard_defconfig
new file mode 100644
index 0000000000..93b8027bc0
--- /dev/null
+++ b/configs/ls2084abbmini_sdcard_defconfig
@@ -0,0 +1,95 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS2084ABBMINI=y
+CONFIG_SYS_TEXT_BASE=0x80400000
+CONFIG_ENV_SIZE=0x2000
+CONFIG_ENV_SECT_SIZE=0x40000
+CONFIG_ENV_OFFSET=0x500000
+CONFIG_FSL_LS_PPA=y
+CONFIG_DM_GPIO=y
+CONFIG_NR_DRAM_BANKS=2
+CONFIG_AHCI=y
+CONFIG_SPL=y
+CONFIG_SPL_TEXT_BASE=0x1800a000
+CONFIG_SPL_ENV_SUPPORT=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_DRIVERS_MISC_SUPPORT=y
+CONFIG_SYS_MALLOC_F_LEN=0x6000
+CONFIG_FIT=y
+CONFIG_FIT_VERBOSE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_OF_STDOUT_VIA_ALIAS=y
+CONFIG_SD_BOOT=y
+CONFIG_BOOTDELAY=10
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x8b0
+CONFIG_HUSH_PARSER=y
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyS1,115200 root=/dev/ram0 earlycon=uart8250,mmio,0x21c0600 ramdisk_size=0x2000000 default_hugepagesz=2m hugepagesz=2m hugepages=256"
+# CONFIG_USE_BOOTCOMMAND is not set
+CONFIG_MISC_INIT_R=y
+CONFIG_CMD_IMLS=y
+CONFIG_CMD_BOOTI=y
+CONFIG_CMD_GREPENV=y
+CONFIG_CMD_EEPROM=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_SETEXPR=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_DATE=y
+CONFIG_MP=y
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-ls2084a-bbmini"
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_ADDR=0x580500000
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM=y
+CONFIG_SATA_CEVA=y
+CONFIG_FSL_CAAM=y
+CONFIG_DM_I2C=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_DEFAULT_BUS_NUMBER=0
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_DM_MMC=y
+CONFIG_FSL_ESDHC=y
+CONFIG_MTD=y
+CONFIG_MTD_NOR_FLASH=y
+CONFIG_FLASH_CFI_DRIVER=y
+CONFIG_SYS_FLASH_USE_BUFFER_WRITE=y
+CONFIG_SYS_FLASH_CFI=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_AQUANTIA=y
+CONFIG_E1000=y
+CONFIG_MII=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCIE_LAYERSCAPE=y
+CONFIG_DM_RTC=y
+CONFIG_DM_SCSI=y
+CONFIG_CONS_INDEX=2
+CONFIG_SYS_NS16550=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_FSL_DSPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_STORAGE=y
+CONFIG_EFI_LOADER_BOUNCE_BUFFER=y
+CONFIG_DISTRO_DEFAULTS=y
diff --git a/include/configs/ls2084abbmini.h b/include/configs/ls2084abbmini.h
new file mode 100644
index 0000000000..9228cfeb3d
--- /dev/null
+++ b/include/configs/ls2084abbmini.h
@@ -0,0 +1,278 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2017-2018, 2020 NXP
+ * Copyright 2015 Freescale Semiconductor
+ */
+
+#ifndef __LS2084A_BBMINI_H
+#define __LS2084A_BBMINI_H
+
+#include "ls2080a_common.h"
+
+#if !defined(CONFIG_SPL_BUILD)
+#define I2C_VOL_MONITOR_ADDR           0x63
+#define CONFIG_VOL_MONITOR_LTC3882_READ
+#define CONFIG_VOL_MONITOR_LTC3882_SET
+#define LTC_VID_CHANNEL 0
+
+#define CONFIG_VID_FLS_ENV		"ls2084abbmini_vdd_mv"
+#define CONFIG_VID
+#endif
+
+/* Backwards compatibility if an old style setup with PPA is booted */
+#if defined(CONFIG_FSL_LS_PPA)
+#define SEC_FIRMWARE_FIT_CNF_NAME	"config@1"
+#endif
+
+/* The lowest and highest voltage allowed */
+#define VDD_MV_MIN			819
+#define VDD_MV_MAX			1212
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+#endif
+
+#if defined(CONFIG_SPL_BUILD)
+#define CONFIG_SYS_NO_FLASH
+#undef CONFIG_CMD_IMLS
+#endif
+
+#if defined(CONFIG_SPL_BUILD)
+#define CONFIG_SYS_CLK_FREQ		100000000
+#else
+#define CONFIG_SYS_CLK_FREQ		get_board_sys_clk()
+#endif
+#define CONFIG_DDR_CLK_FREQ		133333333
+#define COUNTER_FREQUENCY_REAL		(CONFIG_SYS_CLK_FREQ/4)
+
+#define CONFIG_DDR_SPD
+#define CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+#define SPD_EEPROM_ADDRESS1	0x51
+#define SPD_EEPROM_ADDRESS2	0x53
+#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1
+#define CONFIG_SYS_SPD_BUS_NUM	0	/* SPD on I2C bus 0 */
+#define CONFIG_DIMM_SLOTS_PER_CTLR		1
+#define CONFIG_CHIP_SELECTS_PER_CTRL		4
+#undef CONFIG_SYS_NUM_DDR_CTLRS
+#define CONFIG_SYS_NUM_DDR_CTLRS		2
+#undef CONFIG_SYS_FSL_HAS_DP_DDR
+#undef CONFIG_SYS_DP_DDR_BASE_PHY
+
+/* SATA */
+#define CONFIG_SCSI_AHCI_PLAT
+
+#define CONFIG_SYS_SATA1			AHCI_BASE_ADDR1
+
+#define CONFIG_SYS_SCSI_MAX_SCSI_ID		1
+#define CONFIG_SYS_SCSI_MAX_LUN			1
+#define CONFIG_SYS_SCSI_MAX_DEVICE		(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
+						CONFIG_SYS_SCSI_MAX_LUN)
+#if defined (CONFIG_SD_BOOT) || defined(CONFIG_TFABOOT)
+#define CONFIG_SYS_MMC_ENV_DEV         0
+#endif
+
+#if 1
+
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NOR_AMASK		IFC_AMASK(128*1024*1024)
+#define CONFIG_SYS_NOR_AMASK_EARLY	IFC_AMASK(64*1024*1024)
+
+#define CONFIG_SYS_NOR0_CSPR					\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS)		| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR0_CSPR_EARLY				\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS_EARLY)	| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(12)
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
+				FTIM1_NOR_TRAD_NOR(0x1a) |\
+				FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWPH(0x0E) | \
+				FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3	0x04000000
+#define CONFIG_SYS_IFC_CCR	0x01000000
+
+#ifdef CONFIG_MTD_NOR_FLASH
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE,\
+					 CONFIG_SYS_FLASH_BASE + 0x40000000}
+#endif
+
+#define CONFIG_FSL_QIXIS	/* use common QIXIS code */
+#define QIXIS_LBMAP_SWITCH		0x06
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SHIFT		0
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x04
+
+#define QIXIS_LBMAP_SD			QIXIS_LBMAP_DFLTBANK
+#define QIXIS_RCW_SRC_SD		0x40
+
+/* Could only be used with default J30 of 1-2! */
+#define QIXIS_LBMAP_IFC			QIXIS_LBMAP_DFLTBANK
+#define QIXIS_RCW_SRC_IFC		0x25
+
+/* QSPI support via QIXIS is a loaded topic. It could only
+ * be used with a different CPLD image that enables I2C access
+ * as opposed to IFC access.
+ */
+#if 0
+/* Could only be used with changing J30 to 2-3! */
+#define QIXIS_LBMAP_QSPI		QIXIS_LBMAP_DFLTBANK
+#define QIXIS_RCW_SRC_QSPI		0x62
+#endif
+
+#define QIXIS_RST_CTL_RESET		0x31
+#define QIXIS_RST_CTL_RESET_EN		0x30
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+#define	QIXIS_RST_FORCE_MEM		0x01
+
+#define CONFIG_SYS_CSPR3_EXT	(0x0)
+#define CONFIG_SYS_CSPR3	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS_EARLY) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+#define CONFIG_SYS_CSPR3_FINAL	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+
+#define CONFIG_SYS_AMASK3	IFC_AMASK(64*1024)
+#define CONFIG_SYS_CSOR3	CSOR_GPCM_ADM_SHIFT(12)
+/* QIXIS Timing parameters for IFC CS3 */
+#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0xff) | \
+					FTIM1_GPCM_TRAD(0x3f))
+#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0xf) | \
+					FTIM2_GPCM_TCH(0xf) | \
+					FTIM2_GPCM_TWP(0x3E))
+#define CONFIG_SYS_CS3_FTIM3		0x0
+
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR_EARLY
+#define CONFIG_SYS_CSPR0_FINAL		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+
+/* Debug Server firmware */
+#define CONFIG_SYS_DEBUG_SERVER_FW_IN_NOR
+#define CONFIG_SYS_DEBUG_SERVER_FW_ADDR	0x580D00000ULL
+#endif
+#define CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS 5000
+
+
+/*
+ * I2C
+ */
+#define I2C_MUX_PCA_ADDR_PRI		0x75 /* Primary Mux*/
+#define I2C_RETIMER_ADDR		0x18
+#define I2C_ADT7481_ADDR		0x4c
+
+/* I2C bus multiplexer */
+#define I2C_MUX_CH_DEFAULT      0x8
+#define I2C_MUX_CH_ADT7481      0x9
+#define I2C_MUX_CH_RETIMER      0xa
+#define I2C_MUX_CH_VOL_MONITOR  0xc
+
+
+/*
+ * RTC configuration
+ */
+#define RTC
+#define CONFIG_RTC_DS3231               1
+#define CONFIG_SYS_I2C_RTC_ADDR         0x68
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+#define CONFIG_FSL_MEMAC
+
+#ifdef CONFIG_PCI
+#define CONFIG_PCI_SCAN_SHOW
+#endif
+
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_GICSUPPORT
+#define CONFIG_SUPPORT_IRQHANDLERS
+#define CONFIG_CMD_IRQINFO
+#endif
+
+/*  MMC  */
+#ifdef CONFIG_MMC
+#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
+#endif
+
+#define BOOT_TARGET_DEVICES(func) \
+	func(USB, usb, 0) \
+	func(MMC, mmc, 0) \
+	func(SCSI, scsi, 0) \
+	func(DHCP, dhcp, na)
+#include <config_distro_bootcmd.h>
+
+
+/* Initial environment variables */
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
+	"loadaddr=0x80100000\0"			\
+	"kernel_addr=0x100000\0"		\
+	"ramdisk_addr=0x800000\0"		\
+	"ramdisk_size=0x2000000\0"		\
+	"fdt_high=0xa0000000\0"			\
+	"initrd_high=0xffffffffffffffff\0"	\
+	"kernel_start=0x581100000\0"		\
+	"kernel_load=0xa0000000\0"		\
+	"kernel_size=0x2800000\0"		\
+	"mcinitcmd=fsl_mc start mc 0x580300000"	\
+	" 0x580800000 \0"
+
+
+/* MAC/PHY configuration */
+#ifdef CONFIG_FSL_MC_ENET
+
+#define AQ_PHY_ADDR1		0x00
+#define AQ_PHY_ADDR2		0x01
+#define AQ_PHY_ADDR3		0x02
+#define AQR107_IRQ_MASK1	0x02
+#define AQR107_IRQ_MASK2	0x04
+#define AQR107_IRQ_MASK3	0x10
+
+#define CONFIG_ETHPRIME		"DPMAC5@xgmii"
+#endif
+
+#include <asm/fsl_secure_boot.h>
+
+#endif /* __LS2084A_BBMINI_H */
-- 
2.17.1

